{"version":3,"sources":["webpack://gatsby-starter-default/./node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js","webpack://gatsby-starter-default/./node_modules/micromark-extension-gfm-footnote/lib/syntax.js","webpack://gatsby-starter-default/./node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","webpack://gatsby-starter-default/./node_modules/micromark-extension-gfm-table/lib/syntax.js","webpack://gatsby-starter-default/./node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js","webpack://gatsby-starter-default/./node_modules/micromark-extension-gfm/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm-autolink-literal/node_modules/ccount/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-find-and-replace/node_modules/unist-util-is/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-find-and-replace/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm-autolink-literal/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/util/association.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/util/container-flow.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/util/safe.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm-footnote/node_modules/unist-util-is/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm-footnote/node_modules/unist-util-visit-parents/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm-footnote/node_modules/unist-util-visit/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm-footnote/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm-strikethrough/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm-table/node_modules/markdown-table/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm-table/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/handle/list-item.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","webpack://gatsby-starter-default/./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm-task-list-item/index.js","webpack://gatsby-starter-default/./node_modules/mdast-util-gfm/index.js","webpack://gatsby-starter-default/./node_modules/remark-gfm/index.js","webpack://gatsby-starter-default/./src/templates/blogPost.js"],"names":["www","tokenize","effects","ok","nok","code","consume","w2","w3","dot","after","partial","domain","hasUnderscoreInLastSegment","hasUnderscoreInLastLastSegment","check","namedCharacterReference","done","punctuationContinuation","punctuation","undefined","path","balance","inPath","continuedPunctuation","parenAtPathEnd","pathEnd","trailingPunctuation","inside","wwwAutolink","self","this","previousWww","previous","previousUnbalanced","events","enter","attempt","exit","httpAutolink","previousHttp","t1","t2","p","s","colon","slash1","slash2","emailAutolink","hasDot","hasDigitInLastSegment","gfmAtext","previousEmail","atext","label","dotContinuation","dashOrUnderscoreContinuation","afterDashOrUnderscore","gfmAutolinkLiteral","text","index","length","result","token","type","_balanced","_gfmAutolinkLiteralWalkedInto","indent","f","tail","sliceSerialize","tokenizePotentialGfmFootnoteCall","labelStart","defined","parser","gfmFootnotes","id","start","end","now","charCodeAt","includes","slice","resolveToPotentialGfmFootnoteCall","context","call","Object","assign","marker","column","offset","_bufferIndex","string","chunk","contentType","replacement","splice","apply","concat","tokenizeGfmFootnoteCall","data","size","callStart","callData","callEscape","tokenizeDefinitionStart","identifier","_container","atBreak","labelAfter","labelEscape","push","tokenizeDefinitionContinuation","gfmFootnoteDefinitionEnd","gfmStrikethrough","options","arguments","single","singleTilde","tokenizer","tokenizeStrikethrough","resolveAll","resolveAllStrikethrough","insideSpan","null","attentionMarkers","_close","open","_open","strikethrough","nextEvents","constructs","more","before","Boolean","gfmTable","flow","seenDelimiter","hasDash","align","tableHeaderCount","_align","cellDividerHead","inCellContentHead","cellBreakHead","originalInterrupt","interrupt","tokenizeRowEnd","atDelimiterRowBreak","atRowEndHead","inWhitespaceHead","inCellContentEscapeHead","rowEndDelimiter","inWhitespaceDelimiter","inFillerDelimiter","afterLeftAlignment","afterRightAlignment","tableClose","nextPrefixedOrBlank","bodyStart","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","tableBodyClose","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","prefixed","lazy","line","disable","_gfmTableDynamicInterruptHack","resolve","inHead","inDelimiterRow","inRow","contentStart","contentEnd","cellStart","seenCellInRow","content","cell","whitespace","tasklistCheck","_gfmTasklistFirstContentOfListItem","close","spaceThenNonSpace","gfmTaskListItem","gfm","document","continuation","_text","add","resolveTo","ccount","value","character","source","String","TypeError","count","indexOf","convert","test","castFactory","node","typeFactory","Array","isArray","anyFactory","all","key","propsFactory","Error","tests","checks","_len","parameters","_key","_checks$index","_len2","_key2","visitParents","tree","visitor","reverse","is","step","factory","parents","name","tagName","defineProperty","visit","subresult","grandparents","toResult","children","own","hasOwnProperty","findAndReplace","find","replace","settings","schema","RegExp","ignored","ignore","pairs","toExpression","toFunction","toPairs","pairIndex","grandparent","parent","position","nodes","lastIndex","match","exec","input","_nodes","global","_parent$children","handler","inConstruct","notInConstruct","gfmAutolinkLiteralFromMarkdown","transforms","findUrl","findEmail","literalAutolink","title","url","literalAutolinkEmail","enterLiteralAutolinkValue","literalAutolinkHttp","literalAutolinkWww","config","autolinkEmail","autolinkProtocol","stack","gfmAutolinkLiteralToMarkdown","unsafe","_","protocol","prefix","parts","split","isCorrectDomain","closingParenIndex","openingParens","closingParens","trail","trailExec","splitUrl","email","association","containerFlow","indexStack","results","child","handle","bulletLastUsed","between","pop","join","left","right","repeat","eol","indentLines","map","one","patternCompile","pattern","_compiled","patternInScope","listInScope","list","none","safe","positions","infos","expression","sort","numerical","_position","escapeBackslashes","charAt","encode","toString","toUpperCase","a","b","whole","any","warningColonInFootnote","warningListInFootnote","gfmFootnoteToMarkdown","footnoteReference","peek","handlers","footnoteDefinition","subexit","blank","console","warn","reference","containerPhrasing","safeOptions","gfmStrikethroughFromMarkdown","canContainEols","gfmStrikethroughToMarkdown","delete","handleDelete","inlineCode","sequence","serialize","defaultStringLength","toAlignment","codePointAt","gfmTableFromMarkdown","table","d","setData","tableData","enterCell","tableHeader","tableRow","codeText","resume","getData","$0","$1","gfmTableToMarkdown","padding","tableCellPadding","alignDelimiters","tablePipeAlign","stringLength","around","serializeData","handleTableRowAsData","handleTableAsData","tableCell","handleTableCell","matrix","alignments","cellMatrix","sizeMatrix","longestCellByColumn","mostCellsPerRow","rowIndex","_row","_sizes","_columnIndex","columnIndex","row","sizes","_code","_size","Math","max","_cell","lines","_row2","_sizes2","_cell2","_before","_after","_size2","_code2","delimiterStart","delimiterEnd","markdownTable","listItem","listItemIndent","style","checkListItemIndent","bullet","bulletCurrent","checkBullet","ordered","incrementListMarker","spread","ceil","gfmTaskListItemFromMarkdown","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","firstParaghraph","siblings","head","checked","sibling","shift","gfmTaskListItemToMarkdown","gfmFromMarkdown","gfmFootnoteDefinition","gfmFootnoteDefinitionLabelString","buffer","gfmFootnoteCall","gfmFootnoteCallString","toLowerCase","gfmToMarkdown","extensions","remarkGfm","field","pageContext","strapiArticle","slug","description","localizations","strapiGlobal","log","seo","metaDescription","metaTitle","remarkPlugins"],"mappings":"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","file":"component---src-templates-blog-post-js-5ffda07bb1f5599d476c.js","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { asciiAlpha, asciiAlphanumeric, asciiControl, asciiDigit, markdownLineEndingOrSpace, markdownLineEnding, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nvar www = {\n  tokenize: tokenizeWww,\n  partial: true\n};\nvar domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nvar path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nvar punctuation = {\n  tokenize: tokenizePunctuation,\n  partial: true\n};\nvar namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n};\nvar wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nvar httpAutolink = {\n  tokenize: tokenizeHttpAutolink,\n  previous: previousHttp\n};\nvar emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n/** @type {ConstructRecord} */\n\nvar text = {};\n/** @type {Extension} */\n\nexport var gfmAutolinkLiteral = {\n  text: text\n};\nvar code = 48; // Add alphanumerics.\n\nwhile (code < 123) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === 58) code = 65;else if (code === 91) code = 97;\n}\n\ntext[43] = emailAutolink;\ntext[45] = emailAutolink;\ntext[46] = emailAutolink;\ntext[95] = emailAutolink;\ntext[72] = [emailAutolink, httpAutolink];\ntext[104] = [emailAutolink, httpAutolink];\ntext[87] = [emailAutolink, wwwAutolink];\ntext[119] = [emailAutolink, wwwAutolink];\n/** @type {Tokenizer} */\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  var self = this;\n  /** @type {boolean} */\n\n  var hasDot;\n  /** @type {boolean|undefined} */\n\n  var hasDigitInLastSegment;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n  /** @type {State} */\n\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n\n    if (code === 64) {\n      effects.consume(code);\n      return label;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function label(code) {\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code);\n    }\n\n    if (code === 45 || code === 95) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code);\n    }\n\n    if (asciiAlphanumeric(code)) {\n      if (!hasDigitInLastSegment && asciiDigit(code)) {\n        hasDigitInLastSegment = true;\n      }\n\n      effects.consume(code);\n      return label;\n    }\n\n    return done(code);\n  }\n  /** @type {State} */\n\n\n  function dotContinuation(code) {\n    effects.consume(code);\n    hasDot = true;\n    hasDigitInLastSegment = undefined;\n    return label;\n  }\n  /** @type {State} */\n\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code);\n    return afterDashOrUnderscore;\n  }\n  /** @type {State} */\n\n\n  function afterDashOrUnderscore(code) {\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code);\n    }\n\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    if (hasDot && !hasDigitInLastSegment) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 87 && code !== 119 || !previousWww(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww'); // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but thats not how its implemented by them).\n\n    return effects.check(www, effects.attempt(domain, effects.attempt(path, done), nok), nok)(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  var self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code !== 72 && code !== 104 || !previousHttp(self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkHttp');\n    effects.consume(code);\n    return t1;\n  }\n  /** @type {State} */\n\n\n  function t1(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code);\n      return t2;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function t2(code) {\n    if (code === 84 || code === 116) {\n      effects.consume(code);\n      return p;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function p(code) {\n    if (code === 80 || code === 112) {\n      effects.consume(code);\n      return s;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function s(code) {\n    if (code === 83 || code === 115) {\n      effects.consume(code);\n      return colon;\n    }\n\n    return colon(code);\n  }\n  /** @type {State} */\n\n\n  function colon(code) {\n    if (code === 58) {\n      effects.consume(code);\n      return slash1;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function slash1(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return slash2;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function slash2(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    return code === null || asciiControl(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, done), nok)(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return w2;\n  }\n  /** @type {State} */\n\n\n  function w2(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code);\n      return w3;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function w3(code) {\n    if (code === 87 || code === 119) {\n      effects.consume(code);\n      return dot;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function dot(code) {\n    if (code === 46) {\n      effects.consume(code);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? nok(code) : ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean|undefined} */\n  var hasUnderscoreInLastSegment;\n  /** @type {boolean|undefined} */\n\n  var hasUnderscoreInLastLastSegment;\n  return domain;\n  /** @type {State} */\n\n  function domain(code) {\n    if (code === 38) {\n      return effects.check(namedCharacterReference, done, punctuationContinuation)(code);\n    }\n\n    if (code === 46 || code === 95) {\n      return effects.check(punctuation, done, punctuationContinuation)(code);\n    } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www..com`,\n    // so thats Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n\n\n    if (code === null || asciiControl(code) || unicodeWhitespace(code) || code !== 45 && unicodePunctuation(code)) {\n      return done(code);\n    }\n\n    effects.consume(code);\n    return domain;\n  }\n  /** @type {State} */\n\n\n  function punctuationContinuation(code) {\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;\n      hasUnderscoreInLastSegment = undefined;\n      effects.consume(code);\n      return domain;\n    }\n\n    if (code === 95) hasUnderscoreInLastSegment = true;\n    effects.consume(code);\n    return domain;\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizePath(effects, ok) {\n  var balance = 0;\n  return inPath;\n  /** @type {State} */\n\n  function inPath(code) {\n    if (code === 38) {\n      return effects.check(namedCharacterReference, ok, continuedPunctuation)(code);\n    }\n\n    if (code === 40) {\n      balance++;\n    }\n\n    if (code === 41) {\n      return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code);\n    }\n\n    if (pathEnd(code)) {\n      return ok(code);\n    }\n\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code);\n    }\n\n    effects.consume(code);\n    return inPath;\n  }\n  /** @type {State} */\n\n\n  function continuedPunctuation(code) {\n    effects.consume(code);\n    return inPath;\n  }\n  /** @type {State} */\n\n\n  function parenAtPathEnd(code) {\n    balance--;\n    return balance < 0 ? ok(code) : continuedPunctuation(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return inside;\n  }\n  /** @type {State} */\n\n\n  function inside(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return inside;\n    }\n\n    if (code === 59) {\n      effects.consume(code);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, its\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.consume(code);\n    return after;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code);\n      return after;\n    } // If the punctuation marker is followed by the end of the path, its not\n    // continued punctuation.\n\n\n    return pathEnd(code) ? ok(code) : nok(code);\n  }\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\n\nfunction trailingPunctuation(code) {\n  return code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 95 || code === 126;\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\n\nfunction pathEnd(code) {\n  return code === null || code === 60 || markdownLineEndingOrSpace(code);\n}\n/**\n * @param {Code} code\n * @returns {boolean}\n */\n\n\nfunction gfmAtext(code) {\n  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric(code);\n}\n/** @type {Previous} */\n\n\nfunction previousWww(code) {\n  return code === null || code === 40 || code === 42 || code === 95 || code === 126 || markdownLineEndingOrSpace(code);\n}\n/** @type {Previous} */\n\n\nfunction previousHttp(code) {\n  return code === null || !asciiAlpha(code);\n}\n/** @type {Previous} */\n\n\nfunction previousEmail(code) {\n  return code !== 47 && previousHttp(code);\n}\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\n\n\nfunction previousUnbalanced(events) {\n  var index = events.length;\n  var result = false;\n\n  while (index--) {\n    var token = events[index][1];\n\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    } // @ts-expect-error If weve seen this token, and it was marked as not\n    // having any unbalanced bracket before it, we can exit.\n\n\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // @ts-expect-error Mark the last token as walked into w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n\n  return result;\n}","import _defineProperty from \"/Users/frank/Desktop/website_inspiraliving/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n */\nimport { blankLine } from 'micromark-core-commonmark';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nvar indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n/**\n * @returns {Extension}\n */\n\nexport function gfmFootnote() {\n  var _text;\n\n  /** @type {Extension} */\n  return {\n    document: _defineProperty({}, 91, {\n      tokenize: tokenizeDefinitionStart,\n      continuation: {\n        tokenize: tokenizeDefinitionContinuation\n      },\n      exit: gfmFootnoteDefinitionEnd\n    }),\n    text: (_text = {}, _defineProperty(_text, 91, {\n      tokenize: tokenizeGfmFootnoteCall\n    }), _defineProperty(_text, 93, {\n      add: 'after',\n      tokenize: tokenizePotentialGfmFootnoteCall,\n      resolveTo: resolveToPotentialGfmFootnoteCall\n    }), _text)\n  };\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  var self = this;\n  var index = self.events.length;\n  /** @type {Array<string>} */\n  // @ts-expect-error Its fine!\n\n  var defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {Token} */\n\n  var labelStart; // Find an opening.\n\n  while (index--) {\n    var token = self.events[index][1];\n\n    if (token.type === 'labelImage') {\n      labelStart = token;\n      break;\n    } // Exit if weve walked far enough.\n\n\n    if (token.type === 'gfmFootnoteCall' || token.type === 'labelLink' || token.type === 'label' || token.type === 'image' || token.type === 'link') {\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code);\n    }\n\n    var id = normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    }));\n\n    if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code);\n    }\n\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return ok(code);\n  }\n}\n/** @type {Resolver} */\n\n\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  var index = events.length;\n  /** @type {Token|undefined} */\n\n  var labelStart; // Find an opening.\n\n  while (index--) {\n    if (events[index][1].type === 'labelImage' && events[index][0] === 'enter') {\n      labelStart = events[index][1];\n      break;\n    }\n  } // Change the `labelImageMarker` to a `data`.\n\n\n  events[index + 1][1].type = 'data';\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'; // The whole (without `!`):\n\n  var call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }; // The `^` marker\n\n  var marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }; // Increment the end 1 character.\n\n  marker.end.column++;\n  marker.end.offset++;\n  marker.end._bufferIndex++;\n  var string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  };\n  var chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  };\n  /** @type {Array<Event>} */\n\n  var replacement = [// Take the `labelImageMarker` (now `data`, the `!`)\n  events[index + 1], events[index + 2], ['enter', call, context], // The `[`\n  events[index + 3], events[index + 4], // The `^`.\n  ['enter', marker, context], ['exit', marker, context], // Everything in between.\n  ['enter', string, context], ['enter', chunk, context], ['exit', chunk, context], ['exit', string, context], // The ending (`]`, properly parsed and labelled).\n  events[events.length - 2], events[events.length - 1], ['exit', call, context]];\n  events.splice.apply(events, [index, events.length - index + 1].concat(replacement));\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  var self = this;\n  /** @type {Array<string>} */\n  // @ts-expect-error Its fine!\n\n  var defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  var size = 0;\n  /** @type {boolean} */\n\n  var data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteCall');\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return callStart;\n  }\n  /** @type {State} */\n\n\n  function callStart(code) {\n    if (code !== 94) return nok(code);\n    effects.enter('gfmFootnoteCallMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallMarker');\n    effects.enter('gfmFootnoteCallString');\n    effects.enter('chunkString').contentType = 'string';\n    return callData;\n  }\n  /** @type {State} */\n\n\n  function callData(code) {\n    /** @type {Token} */\n    var token;\n\n    if (code === null || code === 91 || size++ > 999) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code);\n      }\n\n      effects.exit('chunkString');\n      token = effects.exit('gfmFootnoteCallString');\n      return defined.includes(normalizeIdentifier(self.sliceSerialize(token))) ? end(code) : nok(code);\n    }\n\n    effects.consume(code);\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n\n    return code === 92 ? callEscape : callData;\n  }\n  /** @type {State} */\n\n\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return callData;\n    }\n\n    return callData(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    effects.exit('gfmFootnoteCall');\n    return ok;\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  var self = this;\n  /** @type {Array<string>} */\n  // @ts-expect-error Its fine!\n\n  var defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {string} */\n\n  var identifier;\n  var size = 0;\n  /** @type {boolean|undefined} */\n\n  var data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true;\n    effects.enter('gfmFootnoteDefinitionLabel');\n    effects.enter('gfmFootnoteDefinitionLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteDefinitionLabelMarker');\n    return labelStart;\n  }\n  /** @type {State} */\n\n\n  function labelStart(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionMarker');\n      effects.enter('gfmFootnoteDefinitionLabelString');\n      return atBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function atBreak(code) {\n    /** @type {Token} */\n    var token;\n\n    if (code === null || code === 91 || size > 999) {\n      return nok(code);\n    }\n\n    if (code === 93) {\n      if (!data) {\n        return nok(code);\n      }\n\n      token = effects.exit('gfmFootnoteDefinitionLabelString');\n      identifier = normalizeIdentifier(self.sliceSerialize(token));\n      effects.enter('gfmFootnoteDefinitionLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionLabelMarker');\n      effects.exit('gfmFootnoteDefinitionLabel');\n      return labelAfter;\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      size++;\n      return atBreak;\n    }\n\n    effects.enter('chunkString').contentType = 'string';\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function label(code) {\n    if (code === null || markdownLineEnding(code) || code === 91 || code === 93 || size > 999) {\n      effects.exit('chunkString');\n      return atBreak(code);\n    }\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n\n    size++;\n    effects.consume(code);\n    return code === 92 ? labelEscape : label;\n  }\n  /** @type {State} */\n\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code);\n      size++;\n      return label;\n    }\n\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker'); // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n\n      return factorySpace(effects, done, 'gfmFootnoteDefinitionWhitespace');\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    if (!defined.includes(identifier)) {\n      defined.push(identifier);\n    }\n\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok));\n}\n/** @type {Exiter} */\n\n\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition');\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeIndent(effects, ok, nok) {\n  var self = this;\n  return factorySpace(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', 4 + 1);\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    var tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok(code) : nok(code);\n  }\n}","import _defineProperty from \"/Users/frank/Desktop/website_inspiraliving/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (`boolean`, default:\n *   `true`).\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\nimport { splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/**\n * @param {Options} [options]\n * @returns {Extension}\n */\n\nexport function gfmStrikethrough() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var single = options.singleTilde;\n  var tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n\n  if (single === null || single === undefined) {\n    single = true;\n  }\n\n  return {\n    text: _defineProperty({}, 126, tokenizer),\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  };\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n\n  function resolveAllStrikethrough(events, context) {\n    var index = -1; // Walk through all events.\n\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        var open = index; // Now walk back to find an opener.\n\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open && // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n            var strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n            var text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }; // Opening.\n\n            var nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]]; // Between.\n\n            splice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)); // Closing.\n\n            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            splice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n\n    index = -1;\n\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data';\n      }\n    }\n\n    return events;\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    var previous = this.previous;\n    var events = this.events;\n    var size = 0;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      if (previous === 126 && events[events.length - 1][1].type !== 'characterEscape') {\n        return nok(code);\n      }\n\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n    /** @type {State} */\n\n\n    function more(code) {\n      var before = classifyCharacter(previous);\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n\n      if (size < 2 && !single) return nok(code);\n      var token = effects.exit('strikethroughSequenceTemporary');\n      var after = classifyCharacter(code);\n      token._open = !after || after === 2 && Boolean(before);\n      token._close = !before || before === 2 && Boolean(after);\n      return ok(code);\n    }\n  }\n}","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\n/** @type {Extension} */\n\nexport var gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n};\nvar nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  var index = -1;\n  /** @type {boolean|undefined} */\n\n  var inHead;\n  /** @type {boolean|undefined} */\n\n  var inDelimiterRow;\n  /** @type {boolean|undefined} */\n\n  var inRow;\n  /** @type {number|undefined} */\n\n  var contentStart;\n  /** @type {number|undefined} */\n\n  var contentEnd;\n  /** @type {number|undefined} */\n\n  var cellStart;\n  /** @type {boolean|undefined} */\n\n  var seenCellInRow;\n\n  while (++index < events.length) {\n    var token = events[index][1];\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n\n      if ( // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        var content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        /** @type {Token} */\n\n        var text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error Its fine.\n          contentType: 'text'\n        };\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\n        index -= contentEnd - contentStart - 3;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n\n    if (events[index][0] === 'exit' && cellStart !== undefined && cellStart + (seenCellInRow ? 0 : 1) < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== 'whitespace'))) {\n      var cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      cellStart = index + 1;\n      seenCellInRow = true;\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n\n      if (inRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeTable(effects, ok, nok) {\n  var self = this;\n  /** @type {Array<Align>} */\n\n  var align = [];\n  var tableHeaderCount = 0;\n  /** @type {boolean|undefined} */\n\n  var seenDelimiter;\n  /** @type {boolean|undefined} */\n\n  var hasDash;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    }\n\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent'); // Cant be space or eols at the start of a construct, so were in a cell.\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n  /** @type {State} */\n\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakHead(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentHead;\n    } // Anything else.\n\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code);\n    }\n\n    effects.exit('tableRow');\n    effects.exit('tableHead');\n    var originalInterrupt = self.interrupt;\n    self.interrupt = true;\n    return effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      effects.enter('tableDelimiterRow');\n      return atDelimiterRowBreak(code);\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      return nok(code);\n    })(code);\n  }\n  /** @type {State} */\n\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push('none');\n      return inFillerDelimiter;\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    } // If we start with a pipe, we open a cell marker.\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    effects.exit('whitespace');\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n\n    effects.exit('tableDelimiterFiller');\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    } // Anything else is not ok.\n\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    } // `|`\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n\n    if (code === null) {\n      return tableClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, bodyStart, 'linePrefix', 4), tableClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n  /** @type {State} */\n\n\n  function rowStartBody(code) {\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    }\n\n    effects.enter('temporaryTableCellContent'); // Cant be space or eols at the start of a construct, so were in a cell.\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n  /** @type {State} */\n\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceBody;\n    } // `|`\n\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakBody(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentBody;\n    } // Anything else.\n\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n\n    if (code === null) {\n      return tableBodyClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, rowStartBody, 'linePrefix', 4), tableBodyClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return factorySpace(effects, prefixed, 'linePrefix');\n    }\n    /** @type {State} */\n\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (self.parser.lazy[self.now().line] || code === null || markdownLineEnding(code)) {\n        return nok(code);\n      }\n\n      var tail = self.events[self.events.length - 1]; // Indented code can interrupt delimiter and body rows.\n\n      if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4) {\n        return nok(code);\n      }\n\n      self._gfmTableDynamicInterruptHack = true;\n      return effects.check(self.parser.constructs.flow, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return nok(code);\n      }, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return ok(code);\n      })(code);\n    }\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  var size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we dont care about tokens, but we open a bogus one\n    // so were valid.\n    effects.enter('check'); // EOL.\n\n    effects.consume(code);\n    return whitespace;\n  }\n  /** @type {State} */\n\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code);\n      size++;\n      return size === 4 ? ok : whitespace;\n    } // EOF or whitespace\n\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code);\n    } // Anything else.\n\n\n    return nok(code);\n  }\n}","import _defineProperty from \"/Users/frank/Desktop/website_inspiraliving/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\n/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEndingOrSpace, markdownLineEnding } from 'micromark-util-character';\nvar tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n};\nexport var gfmTaskListItem = {\n  text: _defineProperty({}, 91, tasklistCheck)\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  var self = this;\n  return open;\n  /** @type {State} */\n\n  function open(code) {\n    if ( // Exit if theres stuff before.\n    self.previous !== null || // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n  /** @type {State} */\n\n\n  function inside(code) {\n    // To match how GH works in comments, use `markdownSpace` (`[ \\t]`) instead\n    // of `markdownLineEndingOrSpace` (`[ \\t\\r\\n]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  var self = this;\n  return factorySpace(effects, after, 'whitespace');\n  /** @type {State} */\n\n  function after(code) {\n    var tail = self.events[self.events.length - 1];\n    return (// We either found spaces\n      (tail && tail[1].type === 'whitespace' || // or it was followed by a line ending, in which case, there has to be\n      // non-whitespace after that line ending, because otherwise wed get an\n      // EOF as the content is closed with blank lines.\n      markdownLineEnding(code)) && code !== null ? ok(code) : nok(code)\n    );\n  }\n}","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options\n * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions\n */\nimport { combineExtensions, combineHtmlExtensions } from 'micromark-util-combine-extensions';\nimport { gfmAutolinkLiteral, gfmAutolinkLiteralHtml } from 'micromark-extension-gfm-autolink-literal';\nimport { gfmFootnote, gfmFootnoteHtml } from 'micromark-extension-gfm-footnote';\nimport { gfmStrikethrough, gfmStrikethroughHtml } from 'micromark-extension-gfm-strikethrough';\nimport { gfmTable, gfmTableHtml } from 'micromark-extension-gfm-table';\nimport { gfmTagfilterHtml } from 'micromark-extension-gfm-tagfilter';\nimport { gfmTaskListItem, gfmTaskListItemHtml } from 'micromark-extension-gfm-task-list-item';\n/**\n * Support GFM or markdown on github.com.\n *\n * @param {Options} [options]\n * @returns {Extension}\n */\n\nexport function gfm(options) {\n  return combineExtensions([gfmAutolinkLiteral, gfmFootnote(), gfmStrikethrough(options), gfmTable, gfmTaskListItem]);\n}\n/**\n * Support to compile GFM to HTML.\n *\n * @param {HtmlOptions} [options]\n * @returns {HtmlExtension}\n */\n\nexport function gfmHtml(options) {\n  return combineHtmlExtensions([gfmAutolinkLiteralHtml, gfmFootnoteHtml(options), gfmStrikethroughHtml, gfmTableHtml, gfmTagfilterHtml, gfmTaskListItemHtml]);\n}","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  var source = String(value);\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character');\n  }\n\n  var count = 0;\n  var index = source.indexOf(character);\n\n  while (index !== -1) {\n    count++;\n    index = source.indexOf(character, index + character.length);\n  }\n\n  return count;\n}","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {string} Type\n * @typedef {Object<string, unknown>} Props\n *\n * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test\n */\n\n/**\n * Check if a node passes a test\n *\n * @callback TestFunctionAnything\n * @param {Node} node\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean|void}\n */\n\n/**\n * Check if a node passes a certain node test\n *\n * @template {Node} X\n * @callback TestFunctionPredicate\n * @param {Node} node\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is X}\n */\n\n/**\n * @callback AssertAnything\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean}\n */\n\n/**\n * Check if a node passes a certain node test\n *\n * @template {Node} Y\n * @callback AssertPredicate\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is Y}\n */\nexport var is =\n/**\n * Check if a node passes a test.\n * When a `parent` node is known the `index` of node should also be given.\n *\n * @type {(\n *   (<T extends Node>(node: unknown, test: T['type']|Partial<T>|TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|TestFunctionPredicate<T>>, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => node is T) &\n *   ((node?: unknown, test?: Test, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => boolean)\n * )}\n */\n\n/**\n * Check if a node passes a test.\n * When a `parent` node is known the `index` of node should also be given.\n *\n * @param {unknown} [node] Node to check\n * @param {Test} [test]\n * When nullish, checks if `node` is a `Node`.\n * When `string`, works like passing `function (node) {return node.type === test}`.\n * When `function` checks if function passed the node is true.\n * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n * When `array`, checks any one of the subtests pass.\n * @param {number|null|undefined} [index] Position of `node` in `parent`\n * @param {Parent|null|undefined} [parent] Parent of `node`\n * @param {unknown} [context] Context object to invoke `test` with\n * @returns {boolean} Whether test passed and `node` is a `Node` (object with `type` set to non-empty `string`).\n */\n// eslint-disable-next-line max-params\nfunction is(node, test, index, parent, context) {\n  var check = convert(test);\n\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite index');\n  }\n\n  if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) {\n    throw new Error('Expected parent node');\n  }\n\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n    throw new Error('Expected both parent and index');\n  } // @ts-expect-error Looks like a node.\n\n\n  return node && node.type && typeof node.type === 'string' ? Boolean(check.call(context, node, index, parent)) : false;\n};\nexport var convert =\n/**\n * @type {(\n *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &\n *   ((test?: Test) => AssertAnything)\n * )}\n */\n\n/**\n * Generate an assertion from a check.\n * @param {Test} [test]\n * When nullish, checks if `node` is a `Node`.\n * When `string`, works like passing `function (node) {return node.type === test}`.\n * When `function` checks if function passed the node is true.\n * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n * When `array`, checks any one of the subtests pass.\n * @returns {AssertAnything}\n */\nfunction convert(test) {\n  if (test === undefined || test === null) {\n    return ok;\n  }\n\n  if (typeof test === 'string') {\n    return typeFactory(test);\n  }\n\n  if (typeof test === 'object') {\n    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);\n  }\n\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n\n  throw new Error('Expected function, string, or object as test');\n};\n/**\n * @param {Array.<Type|Props|TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\n\nfunction anyFactory(tests) {\n  /** @type {Array.<AssertAnything>} */\n  var checks = [];\n  var index = -1;\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index]);\n  }\n\n  return castFactory(any);\n  /**\n   * @this {unknown}\n   * @param {unknown[]} parameters\n   * @returns {boolean}\n   */\n\n  function any() {\n    var index = -1;\n\n    for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {\n      parameters[_key] = arguments[_key];\n    }\n\n    while (++index < checks.length) {\n      var _checks$index;\n\n      if ((_checks$index = checks[index]).call.apply(_checks$index, [this].concat(parameters))) return true;\n    }\n\n    return false;\n  }\n}\n/**\n * Utility to assert each property in `test` is represented in `node`, and each\n * values are strictly equal.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\n\n\nfunction propsFactory(check) {\n  return castFactory(all);\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n\n  function all(node) {\n    /** @type {string} */\n    var key;\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false;\n    }\n\n    return true;\n  }\n}\n/**\n * Utility to convert a string into a function which checks a given nodes type\n * for said string.\n *\n * @param {Type} check\n * @returns {AssertAnything}\n */\n\n\nfunction typeFactory(check) {\n  return castFactory(type);\n  /**\n   * @param {Node} node\n   */\n\n  function type(node) {\n    return node && node.type === check;\n  }\n}\n/**\n * Utility to convert a string into a function which checks a given nodes type\n * for said string.\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\n\n\nfunction castFactory(check) {\n  return assertion;\n  /**\n   * @this {unknown}\n   * @param {Array.<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function assertion() {\n    for (var _len2 = arguments.length, parameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      parameters[_key2] = arguments[_key2];\n    }\n\n    // @ts-expect-error: spreading is fine.\n    return Boolean(check.call.apply(check, [this].concat(parameters)));\n  }\n} // Utility to return true.\n\n\nfunction ok() {\n  return true;\n}","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {CONTINUE|SKIP|EXIT} Action Union of the action types\n * @typedef {number} Index Move to the sibling at index next (after node itself is completely traversed). Useful if mutating the tree, such as removing the node the visitor is currently on, or any of its previous siblings (or next siblings, in case of reverse) Results less than 0 or greater than or equal to children.length stop traversing the parent\n * @typedef {[(Action|null|undefined|void)?, (Index|null|undefined)?]} ActionTuple List with one or two values, the first an action, the second an index.\n * @typedef {null|undefined|Action|Index|ActionTuple|void} VisitorResult Any value that can be returned from a visitor\n */\n\n/**\n * Invoked when a node (matching test, if given) is found.\n * Visitors are free to transform node.\n * They can also transform the parent of node (the last of ancestors).\n * Replacing node itself, if `SKIP` is not returned, still causes its descendants to be visited.\n * If adding or removing previous siblings (or next siblings, in case of reverse) of node,\n * visitor should return a new index (number) to specify the sibling to traverse after node is traversed.\n * Adding or removing next siblings of node (or previous siblings, in case of reverse)\n * is handled as expected without needing to return a new index.\n * Removing the children property of an ancestor still results in them being traversed.\n *\n * @template {Node} V\n * @callback Visitor\n * @param {V} node Found node\n * @param {Array.<Parent>} ancestors Ancestors of node\n * @returns {VisitorResult}\n */\nimport { convert } from 'unist-util-is';\nimport { color } from './color.js';\n/**\n * Continue traversing as normal\n */\n\nexport var CONTINUE = true;\n/**\n * Do not traverse this nodes children\n */\n\nexport var SKIP = 'skip';\n/**\n * Stop traversing immediately\n */\n\nexport var EXIT = false;\nexport var visitParents =\n/**\n * @type {(\n *   (<T extends Node>(tree: Node, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>, visitor: Visitor<T>, reverse?: boolean) => void) &\n *   ((tree: Node, test: Test, visitor: Visitor<Node>, reverse?: boolean) => void) &\n *   ((tree: Node, visitor: Visitor<Node>, reverse?: boolean) => void)\n * )}\n */\n\n/**\n * Visit children of tree which pass a test\n *\n * @param {Node} tree Abstract syntax tree to walk\n * @param {Test} test test Test node\n * @param {Visitor<Node>} visitor Function to run for each node\n * @param {boolean} [reverse] Fisit the tree in reverse, defaults to false\n */\nfunction visitParents(tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor; // @ts-ignore no visitor given, so `visitor` is test.\n\n    visitor = test;\n    test = null;\n  }\n\n  var is = convert(test);\n  var step = reverse ? -1 : 1;\n  factory(tree, null, [])();\n  /**\n   * @param {Node} node\n   * @param {number?} index\n   * @param {Array.<Parent>} parents\n   */\n\n  function factory(node, index, parents) {\n    /** @type {Object.<string, unknown>} */\n    var value = typeof node === 'object' && node !== null ? node : {};\n    /** @type {string} */\n\n    var name;\n\n    if (typeof value.type === 'string') {\n      name = typeof value.tagName === 'string' ? value.tagName : typeof value.name === 'string' ? value.name : undefined;\n      Object.defineProperty(visit, 'name', {\n        value: 'node (' + color(value.type + (name ? '<' + name + '>' : '')) + ')'\n      });\n    }\n\n    return visit;\n\n    function visit() {\n      /** @type {ActionTuple} */\n      var result = [];\n      /** @type {ActionTuple} */\n\n      var subresult;\n      /** @type {number} */\n\n      var offset;\n      /** @type {Array.<Parent>} */\n\n      var grandparents;\n\n      if (!test || is(node, index, parents[parents.length - 1] || null)) {\n        result = toResult(visitor(node, parents));\n\n        if (result[0] === EXIT) {\n          return result;\n        }\n      }\n\n      if (node.children && result[0] !== SKIP) {\n        // @ts-ignore looks like a parent.\n        offset = (reverse ? node.children.length : -1) + step; // @ts-ignore looks like a parent.\n\n        grandparents = parents.concat(node); // @ts-ignore looks like a parent.\n\n        while (offset > -1 && offset < node.children.length) {\n          subresult = factory(node.children[offset], offset, grandparents)();\n\n          if (subresult[0] === EXIT) {\n            return subresult;\n          }\n\n          offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;\n        }\n      }\n\n      return result;\n    }\n  }\n};\n/**\n * @param {VisitorResult} value\n * @returns {ActionTuple}\n */\n\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value];\n  }\n\n  return [value];\n}","import _toConsumableArray from \"/Users/frank/Desktop/website_inspiraliving/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @typedef Options Configuration.\n * @property {Test} [ignore] `unist-util-is` test used to assert parents\n *\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {Content|Root} Node\n * @typedef {Extract<Node, import('mdast').Parent>} Parent\n *\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n *\n * @typedef RegExpMatchObject\n * @property {number} index\n * @property {string} input\n *\n * @typedef {string|RegExp} Find\n * @typedef {string|ReplaceFunction} Replace\n *\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n * @typedef {Object.<string, Replace>} FindAndReplaceSchema\n * @typedef {Array.<FindAndReplaceTuple>} FindAndReplaceList\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n * @typedef {Array.<Pair>} Pairs\n */\n\n/**\n * @callback ReplaceFunction\n * @param {...any} parameters\n * @returns {Array.<PhrasingContent>|PhrasingContent|string|false|undefined|null}\n */\nimport escape from 'escape-string-regexp';\nimport { visitParents } from 'unist-util-visit-parents';\nimport { convert } from 'unist-util-is';\nvar own = {}.hasOwnProperty;\n/**\n * @param tree mdast tree\n * @param find Value to find and remove. When `string`, escaped and made into a global `RegExp`\n * @param [replace] Value to insert.\n *   * When `string`, turned into a Text node.\n *   * When `Function`, called with the results of calling `RegExp.exec` as\n *     arguments, in which case it can return a single or a list of `Node`,\n *     a `string` (which is wrapped in a `Text` node), or `false` to not replace\n * @param [options] Configuration.\n */\n\nexport var findAndReplace =\n/**\n * @type {(\n *   ((tree: Node, find: Find, replace?: Replace, options?: Options) => Node) &\n *   ((tree: Node, schema: FindAndReplaceSchema|FindAndReplaceList, options?: Options) => Node)\n * )}\n **/\n\n/**\n * @param {Node} tree\n * @param {Find|FindAndReplaceSchema|FindAndReplaceList} find\n * @param {Replace|Options} [replace]\n * @param {Options} [options]\n */\nfunction findAndReplace(tree, find, replace, options) {\n  /** @type {Options|undefined} */\n  var settings;\n  /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n\n  var schema;\n\n  if (typeof find === 'string' || find instanceof RegExp) {\n    // @ts-expect-error dont expect options twice.\n    schema = [[find, replace]];\n    settings = options;\n  } else {\n    schema = find; // @ts-expect-error dont expect replace twice.\n\n    settings = replace;\n  }\n\n  if (!settings) {\n    settings = {};\n  }\n\n  var ignored = convert(settings.ignore || []);\n  var pairs = toPairs(schema);\n  var pairIndex = -1;\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor);\n  }\n\n  return tree;\n  /** @type {import('unist-util-visit-parents').Visitor<Text>} */\n\n  function visitor(node, parents) {\n    var index = -1;\n    /** @type {Parent|undefined} */\n\n    var grandparent;\n\n    while (++index < parents.length) {\n      var parent =\n      /** @type {Parent} */\n      parents[index];\n\n      if (ignored(parent, // @ts-expect-error mdast vs. unist parent.\n      grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {\n        return;\n      }\n\n      grandparent = parent;\n    }\n\n    if (grandparent) {\n      return handler(node, grandparent);\n    }\n  }\n  /**\n   * @param {Text} node\n   * @param {Parent} parent\n   * @returns {VisitorResult}\n   */\n\n\n  function handler(node, parent) {\n    var find = pairs[pairIndex][0];\n    var replace = pairs[pairIndex][1];\n    var start = 0; // @ts-expect-error: TS is wrong, some of these children can be text.\n\n    var index = parent.children.indexOf(node);\n    /** @type {Array.<PhrasingContent>} */\n\n    var nodes = [];\n    /** @type {number|undefined} */\n\n    var position;\n    find.lastIndex = 0;\n    var match = find.exec(node.value);\n\n    while (match) {\n      position = match.index; // @ts-expect-error this is perfectly fine, typescript.\n\n      var value = replace.apply(void 0, _toConsumableArray(match).concat([{\n        index: match.index,\n        input: match.input\n      }]));\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {\n          type: 'text',\n          value: value\n        } : undefined;\n      }\n\n      if (value !== false) {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          });\n        }\n\n        if (Array.isArray(value)) {\n          var _nodes;\n\n          (_nodes = nodes).push.apply(_nodes, _toConsumableArray(value));\n        } else if (value) {\n          nodes.push(value);\n        }\n\n        start = position + match[0].length;\n      }\n\n      if (!find.global) {\n        break;\n      }\n\n      match = find.exec(node.value);\n    }\n\n    if (position === undefined) {\n      nodes = [node];\n      index--;\n    } else {\n      var _parent$children;\n\n      if (start < node.value.length) {\n        nodes.push({\n          type: 'text',\n          value: node.value.slice(start)\n        });\n      }\n\n      (_parent$children = parent.children).splice.apply(_parent$children, [index, 1].concat(_toConsumableArray(nodes)));\n    }\n\n    return index + nodes.length + 1;\n  }\n};\n/**\n * @param {FindAndReplaceSchema|FindAndReplaceList} schema\n * @returns {Pairs}\n */\n\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  var result = [];\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema');\n  }\n\n  if (Array.isArray(schema)) {\n    var index = -1;\n\n    while (++index < schema.length) {\n      result.push([toExpression(schema[index][0]), toFunction(schema[index][1])]);\n    }\n  } else {\n    /** @type {string} */\n    var key;\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @param {Find} find\n * @returns {RegExp}\n */\n\n\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find;\n}\n/**\n * @param {Replace} replace\n * @returns {ReplaceFunction}\n */\n\n\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : function () {\n    return replace;\n  };\n}","export default function escapeStringRegexp(string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  } // Escape characters with special meaning either inside or outside character sets.\n  // Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\n\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown/lib/types.js').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction\n * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject\n * @typedef {import('mdast-util-find-and-replace').PhrasingContent} PhrasingContent\n */\nimport { ccount } from 'ccount';\nimport { findAndReplace } from 'mdast-util-find-and-replace';\nimport { unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nvar inConstruct = 'phrasing';\nvar notInConstruct = ['autolink', 'link', 'image', 'label'];\n/** @type {FromMarkdownExtension} */\n\nexport var gfmAutolinkLiteralFromMarkdown = {\n  transforms: [transformGfmAutolinkLiterals],\n  enter: {\n    literalAutolink: enterLiteralAutolink,\n    literalAutolinkEmail: enterLiteralAutolinkValue,\n    literalAutolinkHttp: enterLiteralAutolinkValue,\n    literalAutolinkWww: enterLiteralAutolinkValue\n  },\n  exit: {\n    literalAutolink: exitLiteralAutolink,\n    literalAutolinkEmail: exitLiteralAutolinkEmail,\n    literalAutolinkHttp: exitLiteralAutolinkHttp,\n    literalAutolinkWww: exitLiteralAutolinkWww\n  }\n};\n/** @type {ToMarkdownExtension} */\n\nexport var gfmAutolinkLiteralToMarkdown = {\n  unsafe: [{\n    character: '@',\n    before: '[+\\\\-.\\\\w]',\n    after: '[\\\\-.\\\\w]',\n    inConstruct: inConstruct,\n    notInConstruct: notInConstruct\n  }, {\n    character: '.',\n    before: '[Ww]',\n    after: '[\\\\-.\\\\w]',\n    inConstruct: inConstruct,\n    notInConstruct: notInConstruct\n  }, {\n    character: ':',\n    before: '[ps]',\n    after: '\\\\/',\n    inConstruct: inConstruct,\n    notInConstruct: notInConstruct\n  }]\n};\n/** @type {FromMarkdownHandle} */\n\nfunction enterLiteralAutolink(token) {\n  this.enter({\n    type: 'link',\n    title: null,\n    url: '',\n    children: []\n  }, token);\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token);\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token);\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token);\n  var node =\n  /** @type {Link} */\n  this.stack[this.stack.length - 1];\n  node.url = 'http://' + this.sliceSerialize(token);\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token);\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction exitLiteralAutolink(token) {\n  this.exit(token);\n}\n/** @type {FromMarkdownTransform} */\n\n\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(tree, [[/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl], [/([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/g, findEmail]], {\n    ignore: ['link', 'linkReference']\n  });\n}\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n */\n// eslint-disable-next-line max-params\n\n\nfunction findUrl(_, protocol, domain, path, match) {\n  var prefix = ''; // Not an expected previous character.\n\n  if (!previous(match)) {\n    return false;\n  } // Treat `www` as part of the domain.\n\n\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain;\n    protocol = '';\n    prefix = 'http://';\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false;\n  }\n\n  var parts = splitUrl(domain + path);\n  if (!parts[0]) return false;\n  /** @type {PhrasingContent} */\n\n  var result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{\n      type: 'text',\n      value: protocol + parts[0]\n    }]\n  };\n\n  if (parts[1]) {\n    return [result, {\n      type: 'text',\n      value: parts[1]\n    }];\n  }\n\n  return result;\n}\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n */\n\n\nfunction findEmail(_, atext, label, match) {\n  if ( // Not an expected previous character.\n  !previous(match, true) || // Label ends in not allowed character.\n  /[_-\\d]$/.test(label)) {\n    return false;\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{\n      type: 'text',\n      value: atext + '@' + label\n    }]\n  };\n}\n/**\n * @param {string} domain\n * @returns {boolean}\n */\n\n\nfunction isCorrectDomain(domain) {\n  var parts = domain.split('.');\n\n  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\\d]/.test(parts[parts.length - 2]))) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {string} url\n * @returns {[string, string|undefined]}\n */\n\n\nfunction splitUrl(url) {\n  var trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url);\n  /** @type {number} */\n\n  var closingParenIndex;\n  /** @type {number} */\n\n  var openingParens;\n  /** @type {number} */\n\n  var closingParens;\n  /** @type {string|undefined} */\n\n  var trail;\n\n  if (trailExec) {\n    url = url.slice(0, trailExec.index);\n    trail = trailExec[0];\n    closingParenIndex = trail.indexOf(')');\n    openingParens = ccount(url, '(');\n    closingParens = ccount(url, ')');\n\n    while (closingParenIndex !== -1 && openingParens > closingParens) {\n      url += trail.slice(0, closingParenIndex + 1);\n      trail = trail.slice(closingParenIndex + 1);\n      closingParenIndex = trail.indexOf(')');\n      closingParens++;\n    }\n  }\n\n  return [url, trail];\n}\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean} [email=false]\n * @returns {boolean}\n */\n\n\nfunction previous(match, email) {\n  var code = match.input.charCodeAt(match.index - 1);\n  return (match.index === 0 || unicodeWhitespace(code) || unicodePunctuation(code)) && (!email || code !== 47);\n}","/**\n * @typedef {import('mdast').Association} Association\n */\nimport { decodeString } from 'micromark-util-decode-string';\n/**\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another: controversially,\n * character escapes and references dont work in this matching: `&copy;` does\n * not match ``, and `\\+` does not match `+`.\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how were going to serialize:\n * it has whitespace, casing, and we can ignore most useless character escapes\n * and all character references.\n *\n * @param {Association} node\n * @returns {string}\n */\n\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || '';\n  }\n\n  return decodeString(node.identifier);\n}","/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Join} Join\n * @typedef {import('../types.js').Context} Context\n */\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @returns {string}\n */\nexport function containerFlow(parent, context) {\n  var indexStack = context.indexStack;\n  var children = parent.children || [];\n  /** @type {Array.<string>} */\n\n  var results = [];\n  var index = -1;\n  indexStack.push(-1);\n\n  while (++index < children.length) {\n    var child = children[index];\n    indexStack[indexStack.length - 1] = index;\n    results.push(context.handle(child, parent, context, {\n      before: '\\n',\n      after: '\\n'\n    }));\n\n    if (child.type !== 'list') {\n      context.bulletLastUsed = undefined;\n    }\n\n    if (index < children.length - 1) {\n      results.push(between(child, children[index + 1]));\n    }\n  }\n\n  indexStack.pop();\n  return results.join('');\n  /**\n   * @param {Node} left\n   * @param {Node} right\n   * @returns {string}\n   */\n\n  function between(left, right) {\n    var index = context.join.length;\n\n    while (index--) {\n      var result = context.join[index](left, right, parent, context);\n\n      if (result === true || result === 1) {\n        break;\n      }\n\n      if (typeof result === 'number') {\n        return '\\n'.repeat(1 + result);\n      }\n\n      if (result === false) {\n        return '\\n\\n<!---->\\n\\n';\n      }\n    }\n\n    return '\\n\\n';\n  }\n}","/**\n * @callback Map\n * @param {string} value\n * @param {number} line\n * @param {boolean} blank\n * @returns {string}\n */\nvar eol = /\\r?\\n|\\r/g;\n/**\n * @param {string} value\n * @param {Map} map\n * @returns {string}\n */\n\nexport function indentLines(value, map) {\n  /** @type {Array.<string>} */\n  var result = [];\n  var start = 0;\n  var line = 0;\n  /** @type {RegExpExecArray|null} */\n\n  var match;\n\n  while (match = eol.exec(value)) {\n    one(value.slice(start, match.index));\n    result.push(match[0]);\n    start = match.index + match[0].length;\n    line++;\n  }\n\n  one(value.slice(start));\n  return result.join('');\n  /**\n   * @param {string} value\n   */\n\n  function one(value) {\n    result.push(map(value, line, !value));\n  }\n}","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    var before = (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') + (pattern.before ? '(?:' + pattern.before + ')' : '');\n    pattern._compiled = new RegExp((before ? '(' + before + ')' : '') + (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') + pattern.character + (pattern.after ? '(?:' + pattern.after + ')' : ''), 'g');\n  }\n\n  return pattern._compiled;\n}","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Array.<string>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);\n}\n/**\n * @param {Array.<string>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\n\nfunction listInScope(stack, list, none) {\n  if (!list) {\n    return none;\n  }\n\n  if (typeof list === 'string') {\n    list = [list];\n  }\n\n  var index = -1;\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true;\n    }\n  }\n\n  return false;\n}","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n */\nimport { patternCompile } from './pattern-compile.js';\nimport { patternInScope } from './pattern-in-scope.js';\n/**\n * @param {Context} context\n * @param {string|null|undefined} input\n * @param {SafeOptions & {encode?: Array.<string>}} config\n * @returns {string}\n */\n\nexport function safe(context, input, config) {\n  var value = (config.before || '') + (input || '') + (config.after || '');\n  /** @type {Array.<number>} */\n\n  var positions = [];\n  /** @type {Array.<string>} */\n\n  var result = [];\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n\n  var infos = {};\n  var index = -1;\n\n  while (++index < context.unsafe.length) {\n    var pattern = context.unsafe[index];\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue;\n    }\n\n    var expression = patternCompile(pattern);\n    /** @type {RegExpExecArray|null} */\n\n    var match = void 0;\n\n    while (match = expression.exec(value)) {\n      var before = 'before' in pattern || Boolean(pattern.atBreak);\n      var after = ('after' in pattern);\n      var position = match.index + (before ? match[1].length : 0);\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false;\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false;\n        }\n      } else {\n        positions.push(position);\n        infos[position] = {\n          before: before,\n          after: after\n        };\n      }\n    }\n  }\n\n  positions.sort(numerical);\n  var start = config.before ? config.before.length : 0;\n  var end = value.length - (config.after ? config.after.length : 0);\n  index = -1;\n\n  while (++index < positions.length) {\n    var _position = positions[index]; // Character before or after matched:\n\n    if (_position < start || _position >= end) {\n      continue;\n    } // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n\n\n    if (_position + 1 < end && positions[index + 1] === _position + 1 && infos[_position].after && !infos[_position + 1].before && !infos[_position + 1].after || positions[index - 1] === _position - 1 && infos[_position].before && !infos[_position - 1].before && !infos[_position - 1].after) {\n      continue;\n    }\n\n    if (start !== _position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, _position), '\\\\'));\n    }\n\n    start = _position;\n\n    if (/[!-/:-@[-`{-~]/.test(value.charAt(_position)) && (!config.encode || !config.encode.includes(value.charAt(_position)))) {\n      // Character escape.\n      result.push('\\\\');\n    } else {\n      // Character reference.\n      result.push('&#x' + value.charCodeAt(_position).toString(16).toUpperCase() + ';');\n      start++;\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after));\n  return result.join('');\n}\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\nfunction numerical(a, b) {\n  return a - b;\n}\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\n\n\nfunction escapeBackslashes(value, after) {\n  var expression = /\\\\(?=[!-/:-@[-`{-~])/g;\n  /** @type {Array.<number>} */\n\n  var positions = [];\n  /** @type {Array.<string>} */\n\n  var results = [];\n  var whole = value + after;\n  var index = -1;\n  var start = 0;\n  /** @type {RegExpExecArray|null} */\n\n  var match;\n\n  while (match = expression.exec(whole)) {\n    positions.push(match.index);\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]));\n    }\n\n    results.push('\\\\');\n    start = positions[index];\n  }\n\n  results.push(value.slice(start));\n  return results.join('');\n}","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {string} Type\n * @typedef {Object<string, unknown>} Props\n *\n * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test\n */\n\n/**\n * Check if a node passes a test\n *\n * @callback TestFunctionAnything\n * @param {Node} node\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean|void}\n */\n\n/**\n * Check if a node passes a certain node test\n *\n * @template {Node} X\n * @callback TestFunctionPredicate\n * @param {Node} node\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is X}\n */\n\n/**\n * @callback AssertAnything\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean}\n */\n\n/**\n * Check if a node passes a certain node test\n *\n * @template {Node} Y\n * @callback AssertPredicate\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is Y}\n */\nexport var is =\n/**\n * Check if a node passes a test.\n * When a `parent` node is known the `index` of node should also be given.\n *\n * @type {(\n *   (<T extends Node>(node: unknown, test: T['type']|Partial<T>|TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|TestFunctionPredicate<T>>, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => node is T) &\n *   ((node?: unknown, test?: Test, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => boolean)\n * )}\n */\n\n/**\n * Check if a node passes a test.\n * When a `parent` node is known the `index` of node should also be given.\n *\n * @param {unknown} [node] Node to check\n * @param {Test} [test]\n * When nullish, checks if `node` is a `Node`.\n * When `string`, works like passing `function (node) {return node.type === test}`.\n * When `function` checks if function passed the node is true.\n * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n * When `array`, checks any one of the subtests pass.\n * @param {number|null|undefined} [index] Position of `node` in `parent`\n * @param {Parent|null|undefined} [parent] Parent of `node`\n * @param {unknown} [context] Context object to invoke `test` with\n * @returns {boolean} Whether test passed and `node` is a `Node` (object with `type` set to non-empty `string`).\n */\n// eslint-disable-next-line max-params\nfunction is(node, test, index, parent, context) {\n  var check = convert(test);\n\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite index');\n  }\n\n  if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) {\n    throw new Error('Expected parent node');\n  }\n\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n    throw new Error('Expected both parent and index');\n  } // @ts-expect-error Looks like a node.\n\n\n  return node && node.type && typeof node.type === 'string' ? Boolean(check.call(context, node, index, parent)) : false;\n};\nexport var convert =\n/**\n * @type {(\n *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &\n *   ((test?: Test) => AssertAnything)\n * )}\n */\n\n/**\n * Generate an assertion from a check.\n * @param {Test} [test]\n * When nullish, checks if `node` is a `Node`.\n * When `string`, works like passing `function (node) {return node.type === test}`.\n * When `function` checks if function passed the node is true.\n * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n * When `array`, checks any one of the subtests pass.\n * @returns {AssertAnything}\n */\nfunction convert(test) {\n  if (test === undefined || test === null) {\n    return ok;\n  }\n\n  if (typeof test === 'string') {\n    return typeFactory(test);\n  }\n\n  if (typeof test === 'object') {\n    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);\n  }\n\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n\n  throw new Error('Expected function, string, or object as test');\n};\n/**\n * @param {Array.<Type|Props|TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\n\nfunction anyFactory(tests) {\n  /** @type {Array.<AssertAnything>} */\n  var checks = [];\n  var index = -1;\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index]);\n  }\n\n  return castFactory(any);\n  /**\n   * @this {unknown}\n   * @param {unknown[]} parameters\n   * @returns {boolean}\n   */\n\n  function any() {\n    var index = -1;\n\n    for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {\n      parameters[_key] = arguments[_key];\n    }\n\n    while (++index < checks.length) {\n      var _checks$index;\n\n      if ((_checks$index = checks[index]).call.apply(_checks$index, [this].concat(parameters))) return true;\n    }\n\n    return false;\n  }\n}\n/**\n * Utility to assert each property in `test` is represented in `node`, and each\n * values are strictly equal.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\n\n\nfunction propsFactory(check) {\n  return castFactory(all);\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n\n  function all(node) {\n    /** @type {string} */\n    var key;\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false;\n    }\n\n    return true;\n  }\n}\n/**\n * Utility to convert a string into a function which checks a given nodes type\n * for said string.\n *\n * @param {Type} check\n * @returns {AssertAnything}\n */\n\n\nfunction typeFactory(check) {\n  return castFactory(type);\n  /**\n   * @param {Node} node\n   */\n\n  function type(node) {\n    return node && node.type === check;\n  }\n}\n/**\n * Utility to convert a string into a function which checks a given nodes type\n * for said string.\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\n\n\nfunction castFactory(check) {\n  return assertion;\n  /**\n   * @this {unknown}\n   * @param {Array.<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function assertion() {\n    for (var _len2 = arguments.length, parameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      parameters[_key2] = arguments[_key2];\n    }\n\n    // @ts-expect-error: spreading is fine.\n    return Boolean(check.call.apply(check, [this].concat(parameters)));\n  }\n} // Utility to return true.\n\n\nfunction ok() {\n  return true;\n}","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('./complex-types').Action} Action\n * @typedef {import('./complex-types').Index} Index\n * @typedef {import('./complex-types').ActionTuple} ActionTuple\n * @typedef {import('./complex-types').VisitorResult} VisitorResult\n * @typedef {import('./complex-types').Visitor} Visitor\n */\nimport { convert } from 'unist-util-is';\nimport { color } from './color.js';\n/**\n * Continue traversing as normal\n */\n\nexport var CONTINUE = true;\n/**\n * Do not traverse this nodes children\n */\n\nexport var SKIP = 'skip';\n/**\n * Stop traversing immediately\n */\n\nexport var EXIT = false;\n/**\n * Visit children of tree which pass a test\n *\n * @param tree Abstract syntax tree to walk\n * @param test Test node, optional\n * @param visitor Function to run for each node\n * @param reverse Visit the tree in reverse order, defaults to false\n */\n\nexport var visitParents =\n/**\n * @type {(\n *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\n *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)\n * )}\n */\n\n/**\n * @param {Node} tree\n * @param {Test} test\n * @param {import('./complex-types').Visitor<Node>} visitor\n * @param {boolean} [reverse]\n */\nfunction visitParents(tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor; // @ts-expect-error no visitor given, so `visitor` is test.\n\n    visitor = test;\n    test = null;\n  }\n\n  var is = convert(test);\n  var step = reverse ? -1 : 1;\n  factory(tree, null, [])();\n  /**\n   * @param {Node} node\n   * @param {number?} index\n   * @param {Array.<Parent>} parents\n   */\n\n  function factory(node, index, parents) {\n    /** @type {Object.<string, unknown>} */\n    // @ts-expect-error: hush\n    var value = typeof node === 'object' && node !== null ? node : {};\n    /** @type {string|undefined} */\n\n    var name;\n\n    if (typeof value.type === 'string') {\n      name = typeof value.tagName === 'string' ? value.tagName : typeof value.name === 'string' ? value.name : undefined;\n      Object.defineProperty(visit, 'name', {\n        value: 'node (' + color(value.type + (name ? '<' + name + '>' : '')) + ')'\n      });\n    }\n\n    return visit;\n\n    function visit() {\n      /** @type {ActionTuple} */\n      var result = [];\n      /** @type {ActionTuple} */\n\n      var subresult;\n      /** @type {number} */\n\n      var offset;\n      /** @type {Array.<Parent>} */\n\n      var grandparents;\n\n      if (!test || is(node, index, parents[parents.length - 1] || null)) {\n        result = toResult(visitor(node, parents));\n\n        if (result[0] === EXIT) {\n          return result;\n        }\n      } // @ts-expect-error looks like a parent.\n\n\n      if (node.children && result[0] !== SKIP) {\n        // @ts-expect-error looks like a parent.\n        offset = (reverse ? node.children.length : -1) + step; // @ts-expect-error looks like a parent.\n\n        grandparents = parents.concat(node); // @ts-expect-error looks like a parent.\n\n        while (offset > -1 && offset < node.children.length) {\n          // @ts-expect-error looks like a parent.\n          subresult = factory(node.children[offset], offset, grandparents)();\n\n          if (subresult[0] === EXIT) {\n            return subresult;\n          }\n\n          offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;\n        }\n      }\n\n      return result;\n    }\n  }\n};\n/**\n * @param {VisitorResult} value\n * @returns {ActionTuple}\n */\n\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value];\n  }\n\n  return [value];\n}","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n * @typedef {import('./complex-types').Visitor} Visitor\n */\nimport { visitParents, CONTINUE, SKIP, EXIT } from 'unist-util-visit-parents';\nexport { CONTINUE, SKIP, EXIT };\n/**\n * Visit children of tree which pass a test\n *\n * @param tree Abstract syntax tree to walk\n * @param test Test, optional\n * @param visitor Function to run for each node\n * @param reverse Fisit the tree in reverse, defaults to false\n */\n\nexport var visit =\n/**\n * @type {(\n *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\n *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)\n * )}\n */\n\n/**\n * @param {Node} tree\n * @param {Test} test\n * @param {import('./complex-types').Visitor} visitor\n * @param {boolean} [reverse]\n */\nfunction visit(tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor;\n    visitor = test;\n    test = null;\n  }\n\n  visitParents(tree, test, overload, reverse);\n  /**\n   * @param {Node} node\n   * @param {Array.<Parent>} parents\n   */\n\n  function overload(node, parents) {\n    var parent = parents[parents.length - 1];\n    return visitor(node, parent ? parent.children.indexOf(node) : null, parent);\n  }\n};","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { association } from 'mdast-util-to-markdown/lib/util/association.js';\nimport { containerFlow } from 'mdast-util-to-markdown/lib/util/container-flow.js';\nimport { indentLines } from 'mdast-util-to-markdown/lib/util/indent-lines.js';\nimport { safe } from 'mdast-util-to-markdown/lib/util/safe.js';\nimport { visit, EXIT } from 'unist-util-visit';\nvar warningColonInFootnote = false;\nvar warningListInFootnote = false;\n/**\n * @returns {FromMarkdownExtension}\n */\n\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteDefinition: enterFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteCallString: enterFootnoteCallString\n    },\n    exit: {\n      gfmFootnoteDefinition: exitFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteCallString: exitFootnoteCallString\n    }\n  };\n  /** @type {FromMarkdownHandle} */\n\n  function enterFootnoteDefinition(token) {\n    this.enter({\n      type: 'footnoteDefinition',\n      identifier: '',\n      label: '',\n      children: []\n    }, token);\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function enterFootnoteDefinitionLabelString() {\n    this.buffer();\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitFootnoteDefinitionLabelString(token) {\n    var label = this.resume();\n    var node =\n    /** @type {FootnoteDefinition} */\n    this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitFootnoteDefinition(token) {\n    this.exit(token);\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function enterFootnoteCall(token) {\n    this.enter({\n      type: 'footnoteReference',\n      identifier: '',\n      label: ''\n    }, token);\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function enterFootnoteCallString() {\n    this.buffer();\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitFootnoteCallString(token) {\n    var label = this.resume();\n    var node =\n    /** @type {FootnoteDefinition} */\n    this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitFootnoteCall(token) {\n    this.exit(token);\n  }\n}\n/**\n * @returns {ToMarkdownExtension}\n */\n\nexport function gfmFootnoteToMarkdown() {\n  footnoteReference.peek = footnoteReferencePeek;\n  return {\n    // This is on by default already.\n    unsafe: [{\n      character: '[',\n      inConstruct: ['phrasing', 'label', 'reference']\n    }],\n    handlers: {\n      footnoteDefinition: footnoteDefinition,\n      footnoteReference: footnoteReference\n    }\n  };\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {FootnoteReference} node\n   */\n\n  function footnoteReference(node, _, context) {\n    var exit = context.enter('footnoteReference');\n    var subexit = context.enter('reference');\n    var reference = safe(context, association(node), {\n      before: '^',\n      after: ']'\n    });\n    subexit();\n    exit();\n    return '[^' + reference + ']';\n  }\n  /** @type {ToMarkdownHandle} */\n\n\n  function footnoteReferencePeek() {\n    return '[';\n  }\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {FootnoteDefinition} node\n   */\n\n\n  function footnoteDefinition(node, _, context) {\n    var exit = context.enter('footnoteDefinition');\n    var subexit = context.enter('label');\n    var id = safe(context, association(node), {\n      before: '^',\n      after: ']'\n    });\n    var label = '[^' + id + ']:';\n    subexit();\n    var value = indentLines(containerFlow(node, context), map);\n    exit();\n\n    if (!warningColonInFootnote && id.includes(':')) {\n      console.warn('[mdast-util-gfm-footnote] Warning: Found a colon in footnote identifier `' + id + '`. GitHub currently crahes on colons in footnotes (see <https://github.com/github/cmark-gfm/issues/241> for more info)');\n      warningColonInFootnote = true;\n    }\n\n    if (!warningListInFootnote) {\n      visit(node, 'list', function () {\n        console.warn('[mdast-util-gfm-footnote] Warning: Found a list in a footnote definition. GitHub currently crahes on lists in footnotes (see <https://github.com/github/cmark-gfm/issues/241> for more info)');\n        warningListInFootnote = true;\n        return EXIT;\n      });\n    }\n\n    return value;\n    /** @type {Map} */\n\n    function map(line, index, blank) {\n      if (index) {\n        return (blank ? '' : '    ') + line;\n      }\n\n      return (blank ? label : label + ' ') + line;\n    }\n  }\n}","/**\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n * @typedef {import('../types.js').Context} Context\n */\n\n/**\n * @param {Parent} parent\n * @param {Context} context\n * @param {SafeOptions} safeOptions\n * @returns {string}\n */\nexport function containerPhrasing(parent, context, safeOptions) {\n  var indexStack = context.indexStack;\n  var children = parent.children || [];\n  /** @type {Array.<string>} */\n\n  var results = [];\n  var index = -1;\n  var before = safeOptions.before;\n  indexStack.push(-1);\n\n  while (++index < children.length) {\n    var child = children[index];\n    /** @type {string} */\n\n    var after = void 0;\n    indexStack[indexStack.length - 1] = index;\n\n    if (index + 1 < children.length) {\n      // @ts-expect-error: hush, its actually a `zwitch`.\n      var handle = context.handle.handlers[children[index + 1].type];\n      if (handle && handle.peek) handle = handle.peek;\n      after = handle ? handle(children[index + 1], parent, context, {\n        before: '',\n        after: ''\n      }).charAt(0) : '';\n    } else {\n      after = safeOptions.after;\n    } // In some cases, html (text) can be found in phrasing right after an eol.\n    // When wed serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we cant escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n\n\n    if (results.length > 0 && (before === '\\r' || before === '\\n') && child.type === 'html') {\n      results[results.length - 1] = results[results.length - 1].replace(/(\\r?\\n|\\r)$/, ' ');\n      before = ' ';\n    }\n\n    results.push(context.handle(child, parent, context, {\n      before: before,\n      after: after\n    }));\n    before = results[results.length - 1].slice(-1);\n  }\n\n  indexStack.pop();\n  return results.join('');\n}","/**\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\nimport { containerPhrasing } from 'mdast-util-to-markdown/lib/util/container-phrasing.js';\n/** @type {FromMarkdownExtension} */\n\nexport var gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {\n    strikethrough: enterStrikethrough\n  },\n  exit: {\n    strikethrough: exitStrikethrough\n  }\n};\n/** @type {ToMarkdownExtension} */\n\nexport var gfmStrikethroughToMarkdown = {\n  unsafe: [{\n    character: '~',\n    inConstruct: 'phrasing'\n  }],\n  handlers: {\n    delete: handleDelete\n  }\n};\nhandleDelete.peek = peekDelete;\n/** @type {FromMarkdownHandle} */\n\nfunction enterStrikethrough(token) {\n  this.enter({\n    type: 'delete',\n    children: []\n  }, token);\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction exitStrikethrough(token) {\n  this.exit(token);\n}\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\n\n\nfunction handleDelete(node, _, context) {\n  var exit = context.enter('emphasis');\n  var value = containerPhrasing(node, context, {\n    before: '~',\n    after: '~'\n  });\n  exit();\n  return '~~' + value + '~~';\n}\n/** @type {ToMarkdownHandle} */\n\n\nfunction peekDelete() {\n  return '~';\n}","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Handle} Handle\n */\nimport { patternCompile } from '../util/pattern-compile.js';\ninlineCode.peek = inlineCodePeek;\n/**\n * @type {Handle}\n * @param {InlineCode} node\n */\n\nexport function inlineCode(node, _, context) {\n  var value = node.value || '';\n  var sequence = '`';\n  var index = -1; // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`';\n  } // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n\n\n  if (/[^ \\r\\n]/.test(value) && (/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) || /^`|`$/.test(value))) {\n    value = ' ' + value + ' ';\n  } // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n\n\n  while (++index < context.unsafe.length) {\n    var pattern = context.unsafe[index];\n    var expression = patternCompile(pattern);\n    /** @type {RegExpExecArray|null} */\n\n    var match = void 0; // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n\n    if (!pattern.atBreak) continue;\n\n    while (match = expression.exec(value)) {\n      var position = match.index; // Support CRLF (patterns only look for one of the characters).\n\n      if (value.charCodeAt(position) === 10\n      /* `\\n` */\n      && value.charCodeAt(position - 1) === 13\n      /* `\\r` */\n      ) {\n        position--;\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n    }\n  }\n\n  return sequence + value + sequence;\n}\n/**\n * @type {Handle}\n */\n\nfunction inlineCodePeek() {\n  return '`';\n}","/**\n * @typedef Options\n *   Configuration (optional).\n * @property {string|null|Array<string|null|undefined>} [align]\n *   One style for all columns, or styles for their respective columns.\n *   Each style is either `'l'` (left), `'r'` (right), or `'c'` (center).\n *   Other values are treated as `''`, which doesnt place the colon in the\n *   alignment row but does align left.\n *   *Only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean} [padding=true]\n *   Whether to add a space of padding between delimiters and cells.\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {boolean} [delimiterStart=true]\n *   Whether to begin each row with the delimiter.\n *\n *   >  **Note**: please dont use this: it could create fragile structures\n *   > that arent understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean} [delimiterEnd=true]\n *   Whether to end each row with the delimiter.\n *\n *   >  **Note**: please dont use this: it could create fragile structures\n *   > that arent understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean} [alignDelimiters=true]\n *   Whether to align the delimiters.\n *   By default, they are aligned:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {(value: string) => number} [stringLength]\n *   Function to detect the length of table cell content.\n *   This is used when aligning the delimiters (`|`) between table cells.\n *   Full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source.\n *   To fix this, you can pass this function, which receives the cell content\n *   and returns its visible size.\n *   Note that what is and isnt visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['', 'Charlie'],\n *     ['', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   |  | Charlie |\n *   |  | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['', 'Charlie'],\n *       ['', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   |   | Charlie |\n *   |     | Delta   |\n *   ```\n */\n\n/**\n * @typedef {Options} MarkdownTableOptions\n * @todo\n *   Remove next major.\n */\n\n/**\n * Generate a markdown ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables)) table..\n *\n * @param {Array<Array<string|null|undefined>>} table\n *   Table data (matrix of strings).\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n */\nexport function markdownTable(table) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var align = (options.align || []).concat();\n  var stringLength = options.stringLength || defaultStringLength;\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n\n  var alignments = [];\n  /** @type {Array<Array<string>>} Cells per row. */\n\n  var cellMatrix = [];\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n\n  var sizeMatrix = [];\n  /** @type {Array<number>} */\n\n  var longestCellByColumn = [];\n  var mostCellsPerRow = 0;\n  var rowIndex = -1; // This is a superfluous loop if we dont align delimiters, but otherwise wed\n  // do superfluous work when aligning, so optimize for aligning.\n\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    var _row = [];\n    /** @type {Array<number>} */\n\n    var _sizes = [];\n\n    var _columnIndex = -1;\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length;\n    }\n\n    while (++_columnIndex < table[rowIndex].length) {\n      var cell = serialize(table[rowIndex][_columnIndex]);\n\n      if (options.alignDelimiters !== false) {\n        var size = stringLength(cell);\n        _sizes[_columnIndex] = size;\n\n        if (longestCellByColumn[_columnIndex] === undefined || size > longestCellByColumn[_columnIndex]) {\n          longestCellByColumn[_columnIndex] = size;\n        }\n      }\n\n      _row.push(cell);\n    }\n\n    cellMatrix[rowIndex] = _row;\n    sizeMatrix[rowIndex] = _sizes;\n  } // Figure out which alignments to use.\n\n\n  var columnIndex = -1;\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex]);\n    }\n  } else {\n    var code = toAlignment(align);\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code;\n    }\n  } // Inject the alignment row.\n\n\n  columnIndex = -1;\n  /** @type {Array<string>} */\n\n  var row = [];\n  /** @type {Array<number>} */\n\n  var sizes = [];\n\n  while (++columnIndex < mostCellsPerRow) {\n    var _code = alignments[columnIndex];\n    var before = '';\n    var after = '';\n\n    if (_code === 99\n    /* `c` */\n    ) {\n      before = ':';\n      after = ':';\n    } else if (_code === 108\n    /* `l` */\n    ) {\n      before = ':';\n    } else if (_code === 114\n    /* `r` */\n    ) {\n      after = ':';\n    } // There *must* be at least one hyphen-minus in each alignment cell.\n\n\n    var _size = options.alignDelimiters === false ? 1 : Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length);\n\n    var _cell = before + '-'.repeat(_size) + after;\n\n    if (options.alignDelimiters !== false) {\n      _size = before.length + _size + after.length;\n\n      if (_size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = _size;\n      }\n\n      sizes[columnIndex] = _size;\n    }\n\n    row[columnIndex] = _cell;\n  } // Inject the alignment row.\n\n\n  cellMatrix.splice(1, 0, row);\n  sizeMatrix.splice(1, 0, sizes);\n  rowIndex = -1;\n  /** @type {Array<string>} */\n\n  var lines = [];\n\n  while (++rowIndex < cellMatrix.length) {\n    var _row2 = cellMatrix[rowIndex];\n    var _sizes2 = sizeMatrix[rowIndex];\n    columnIndex = -1;\n    /** @type {Array<string>} */\n\n    var line = [];\n\n    while (++columnIndex < mostCellsPerRow) {\n      var _cell2 = _row2[columnIndex] || '';\n\n      var _before = '';\n      var _after = '';\n\n      if (options.alignDelimiters !== false) {\n        var _size2 = longestCellByColumn[columnIndex] - (_sizes2[columnIndex] || 0);\n\n        var _code2 = alignments[columnIndex];\n\n        if (_code2 === 114\n        /* `r` */\n        ) {\n          _before = ' '.repeat(_size2);\n        } else if (_code2 === 99\n        /* `c` */\n        ) {\n          if (_size2 % 2) {\n            _before = ' '.repeat(_size2 / 2 + 0.5);\n            _after = ' '.repeat(_size2 / 2 - 0.5);\n          } else {\n            _before = ' '.repeat(_size2 / 2);\n            _after = _before;\n          }\n        } else {\n          _after = ' '.repeat(_size2);\n        }\n      }\n\n      if (options.delimiterStart !== false && !columnIndex) {\n        line.push('|');\n      }\n\n      if (options.padding !== false && // Dont add the opening space if were not aligning and the cell is\n      // empty: there will be a closing space.\n      !(options.alignDelimiters === false && _cell2 === '') && (options.delimiterStart !== false || columnIndex)) {\n        line.push(' ');\n      }\n\n      if (options.alignDelimiters !== false) {\n        line.push(_before);\n      }\n\n      line.push(_cell2);\n\n      if (options.alignDelimiters !== false) {\n        line.push(_after);\n      }\n\n      if (options.padding !== false) {\n        line.push(' ');\n      }\n\n      if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {\n        line.push('|');\n      }\n    }\n\n    lines.push(options.delimiterEnd === false ? line.join('').replace(/ +$/, '') : line.join(''));\n  }\n\n  return lines.join('\\n');\n}\n/**\n * @param {string|null|undefined} [value]\n * @returns {string}\n */\n\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value);\n}\n/**\n * @param {string} value\n * @returns {number}\n */\n\n\nfunction defaultStringLength(value) {\n  return value.length;\n}\n/**\n * @param {string|null|undefined} value\n * @returns {number}\n */\n\n\nfunction toAlignment(value) {\n  var code = typeof value === 'string' ? value.codePointAt(0) : 0;\n  return code === 67\n  /* `C` */\n  || code === 99\n  /* `c` */\n  ? 99\n  /* `c` */\n  : code === 76\n  /* `L` */\n  || code === 108\n  /* `l` */\n  ? 108\n  /* `l` */\n  : code === 82\n  /* `R` */\n  || code === 114\n  /* `r` */\n  ? 114\n  /* `r` */\n  : 0;\n}","/**\n * @typedef {import('mdast').AlignType} AlignType\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n *\n * @typedef Options\n * @property {boolean} [tableCellPadding=true]\n * @property {boolean} [tablePipeAlign=true]\n * @property {MarkdownTableOptions['stringLength']} [stringLength]\n */\nimport { containerPhrasing } from 'mdast-util-to-markdown/lib/util/container-phrasing.js';\nimport { inlineCode } from 'mdast-util-to-markdown/lib/handle/inline-code.js';\nimport { markdownTable } from 'markdown-table';\n/** @type {FromMarkdownExtension} */\n\nexport var gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n};\n/** @type {FromMarkdownHandle} */\n\nfunction enterTable(token) {\n  /** @type {Array<'left'|'right'|'center'|'none'>} */\n  // @ts-expect-error: `align` is custom.\n  var align = token._align;\n  this.enter({\n    type: 'table',\n    align: align.map(function (d) {\n      return d === 'none' ? null : d;\n    }),\n    children: []\n  }, token);\n  this.setData('inTable', true);\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction exitTable(token) {\n  this.exit(token);\n  this.setData('inTable');\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction enterRow(token) {\n  this.enter({\n    type: 'tableRow',\n    children: []\n  }, token);\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction exit(token) {\n  this.exit(token);\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction enterCell(token) {\n  this.enter({\n    type: 'tableCell',\n    children: []\n  }, token);\n} // Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n\n/** @type {FromMarkdownHandle} */\n\n\nfunction exitCodeText(token) {\n  var value = this.resume();\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace);\n  }\n\n  var node =\n  /** @type {InlineCode} */\n  this.stack[this.stack.length - 1];\n  node.value = value;\n  this.exit(token);\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\n\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes dont (but cant escape pipes).\n  return $1 === '|' ? $1 : $0;\n}\n/**\n * @param {Options} [options]\n * @returns {ToMarkdownExtension}\n */\n\n\nexport function gfmTableToMarkdown(options) {\n  var settings = options || {};\n  var padding = settings.tableCellPadding;\n  var alignDelimiters = settings.tablePipeAlign;\n  var stringLength = settings.stringLength;\n  var around = padding ? ' ' : '|';\n  return {\n    unsafe: [{\n      character: '\\r',\n      inConstruct: 'tableCell'\n    }, {\n      character: '\\n',\n      inConstruct: 'tableCell'\n    }, // A pipe, when followed by a tab or space (padding), or a dash or colon\n    // (unpadded delimiter row), could result in a table.\n    {\n      atBreak: true,\n      character: '|',\n      after: '[\\t :-]'\n    }, // A pipe in a cell must be encoded.\n    {\n      character: '|',\n      inConstruct: 'tableCell'\n    }, // A colon must be followed by a dash, in which case it could start a\n    // delimiter row.\n    {\n      atBreak: true,\n      character: ':',\n      after: '-'\n    }, // A delimiter row can also start with a dash, when followed by more\n    // dashes, a colon, or a pipe.\n    // This is a stricter version than the built in check for lists, thematic\n    // breaks, and setex heading underlines though:\n    // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n    {\n      atBreak: true,\n      character: '-',\n      after: '[:|-]'\n    }],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  };\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n\n  function handleTable(node, _, context) {\n    // @ts-expect-error: fixed in `markdown-table@3.0.1`.\n    return serializeData(handleTableAsData(node, context), node.align);\n  }\n  /**\n   * This function isnt really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n\n\n  function handleTableRow(node, _, context) {\n    var row = handleTableRowAsData(node, context); // `markdown-table` will always add an align row\n\n    var value = serializeData([row]);\n    return value.slice(0, value.indexOf('\\n'));\n  }\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n\n\n  function handleTableCell(node, _, context) {\n    var exit = context.enter('tableCell');\n    var subexit = context.enter('phrasing');\n    var value = containerPhrasing(node, context, {\n      before: around,\n      after: around\n    });\n    subexit();\n    exit();\n    return value;\n  }\n  /**\n   * @param {Array.<Array.<string>>} matrix\n   * @param {Array.<string>} [align]\n   */\n\n\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align: align,\n      alignDelimiters: alignDelimiters,\n      padding: padding,\n      stringLength: stringLength\n    });\n  }\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   */\n\n\n  function handleTableAsData(node, context) {\n    var children = node.children;\n    var index = -1;\n    /** @type {Array.<Array.<string>>} */\n\n    var result = [];\n    var subexit = context.enter('table');\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(children[index], context);\n    }\n\n    subexit();\n    return result;\n  }\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   */\n\n\n  function handleTableRowAsData(node, context) {\n    var children = node.children;\n    var index = -1;\n    /** @type {Array.<string>} */\n\n    var result = [];\n    var subexit = context.enter('tableRow');\n\n    while (++index < children.length) {\n      result[index] = handleTableCell(children[index], node, context);\n    }\n\n    subexit();\n    return result;\n  }\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n\n\n  function inlineCodeWithTable(node, parent, context) {\n    var value = inlineCode(node, parent, context);\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&');\n    }\n\n    return value;\n  }\n}","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').List} List\n * @typedef {import('../util/indent-lines.js').Map} Map\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').Handle} Handle\n */\nimport { checkBullet } from '../util/check-bullet.js';\nimport { checkListItemIndent } from '../util/check-list-item-indent.js';\nimport { containerFlow } from '../util/container-flow.js';\nimport { indentLines } from '../util/indent-lines.js';\n/**\n * @type {Handle}\n * @param {ListItem} node\n */\n\nexport function listItem(node, parent, context) {\n  var listItemIndent = checkListItemIndent(context);\n  var bullet = context.bulletCurrent || checkBullet(context); // Add the marker value for ordered lists.\n\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet = (typeof parent.start === 'number' && parent.start > -1 ? parent.start : 1) + (context.options.incrementListMarker === false ? 0 : parent.children.indexOf(node)) + bullet;\n  }\n\n  var size = bullet.length + 1;\n\n  if (listItemIndent === 'tab' || listItemIndent === 'mixed' && (parent && parent.type === 'list' && parent.spread || node.spread)) {\n    size = Math.ceil(size / 4) * 4;\n  }\n\n  var exit = context.enter('listItem');\n  var value = indentLines(containerFlow(node, context), map);\n  exit();\n  return value;\n  /** @type {Map} */\n\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line;\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line;\n  }\n}","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['listItemIndent'], undefined>}\n */\nexport function checkListItemIndent(context) {\n  var style = context.options.listItemIndent || 'tab'; // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n\n  if (style === 1 || style === '1') {\n    return 'one';\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error('Cannot serialize items with `' + style + '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`');\n  }\n\n  return style;\n}","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {Context} context\n * @returns {Exclude<Options['bullet'], undefined>}\n */\nexport function checkBullet(context) {\n  var marker = context.options.bullet || '*';\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error('Cannot serialize items with `' + marker + '` for `options.bullet`, expected `*`, `+`, or `-`');\n  }\n\n  return marker;\n}","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').BlockContent} BlockContent\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\nimport { listItem } from 'mdast-util-to-markdown/lib/handle/list-item.js';\n/** @type {FromMarkdownExtension} */\n\nexport var gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n};\n/** @type {ToMarkdownExtension} */\n\nexport var gfmTaskListItemToMarkdown = {\n  unsafe: [{\n    atBreak: true,\n    character: '-',\n    after: '[:|-]'\n  }],\n  handlers: {\n    listItem: listItemWithTaskListItem\n  }\n};\n/** @type {FromMarkdownHandle} */\n\nfunction exitCheck(token) {\n  // Were always in a paragraph, in a list item.\n  this.stack[this.stack.length - 2].checked = token.type === 'taskListCheckValueChecked';\n}\n/** @type {FromMarkdownHandle} */\n\n\nfunction exitParagraphWithTaskListItem(token) {\n  var parent = this.stack[this.stack.length - 2];\n  /** @type {Paragraph} */\n  // @ts-expect-error: must be true.\n\n  var node = this.stack[this.stack.length - 1];\n  /** @type {BlockContent[]} */\n  // @ts-expect-error: check whether `parent` is a `listItem` later.\n\n  var siblings = parent.children;\n  var head = node.children[0];\n  var index = -1;\n  /** @type {Paragraph|undefined} */\n\n  var firstParaghraph;\n\n  if (parent && parent.type === 'listItem' && typeof parent.checked === 'boolean' && head && head.type === 'text') {\n    while (++index < siblings.length) {\n      var sibling = siblings[index];\n\n      if (sibling.type === 'paragraph') {\n        firstParaghraph = sibling;\n        break;\n      }\n    }\n\n    if (firstParaghraph === node) {\n      // Must start with a space or a tab.\n      head.value = head.value.slice(1);\n\n      if (head.value.length === 0) {\n        node.children.shift();\n      } else {\n        // @ts-expect-error: must be true.\n        head.position.start.column++; // @ts-expect-error: must be true.\n\n        head.position.start.offset++; // @ts-expect-error: must be true.\n\n        node.position.start = Object.assign({}, head.position.start);\n      }\n    }\n  }\n\n  this.exit(token);\n}\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\n\n\nfunction listItemWithTaskListItem(node, parent, context) {\n  var head = node.children[0];\n  var value = listItem(node, parent, context);\n\n  if (typeof node.checked === 'boolean' && head && head.type === 'paragraph') {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check);\n  }\n\n  return value;\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n\n  function check($0) {\n    return $0 + '[' + (node.checked ? 'x' : ' ') + '] ';\n  }\n}","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('mdast-util-gfm-table').Options} Options\n */\nimport { gfmAutolinkLiteralFromMarkdown, gfmAutolinkLiteralToMarkdown } from 'mdast-util-gfm-autolink-literal';\nimport { gfmFootnoteFromMarkdown, gfmFootnoteToMarkdown } from 'mdast-util-gfm-footnote';\nimport { gfmStrikethroughFromMarkdown, gfmStrikethroughToMarkdown } from 'mdast-util-gfm-strikethrough';\nimport { gfmTableFromMarkdown, gfmTableToMarkdown } from 'mdast-util-gfm-table';\nimport { gfmTaskListItemFromMarkdown, gfmTaskListItemToMarkdown } from 'mdast-util-gfm-task-list-item';\n/**\n * @returns {Array.<FromMarkdownExtension>}\n */\n\nexport function gfmFromMarkdown() {\n  return [gfmAutolinkLiteralFromMarkdown, gfmFootnoteFromMarkdown(), gfmStrikethroughFromMarkdown, gfmTableFromMarkdown, gfmTaskListItemFromMarkdown];\n}\n/**\n * @param {Options} [options]\n * @returns {ToMarkdownExtension}\n */\n\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [gfmAutolinkLiteralToMarkdown, gfmFootnoteToMarkdown(), gfmStrikethroughToMarkdown, gfmTableToMarkdown(options), gfmTaskListItemToMarkdown]\n  };\n}","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options\n */\nimport { gfm } from 'micromark-extension-gfm';\nimport { gfmFromMarkdown, gfmToMarkdown } from 'mdast-util-gfm';\n/**\n * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root>}\n */\n\nexport default function remarkGfm() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var data = this.data();\n  add('micromarkExtensions', gfm(options));\n  add('fromMarkdownExtensions', gfmFromMarkdown());\n  add('toMarkdownExtensions', gfmToMarkdown(options));\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n\n  function add(field, value) {\n    var list =\n    /** @type {unknown[]} */\n    // Other extensions\n\n    /* c8 ignore next 2 */\n    data[field] ? data[field] : data[field] = [];\n    list.push(value);\n  }\n}","import React from \"react\"\nimport { graphql } from \"gatsby\"\nimport Layout from \"@/components/layout\"\nimport SEO from \"@/components/seo\"\nimport ReactMarkdown from \"react-markdown\"\nimport remarkGfm from \"remark-gfm\"\n\nconst BlogPost = ({ data, pageContext }) => {\n  const {\n    slug,\n    title,\n    description,\n    content,\n    localizations,\n  } = data.strapiArticle\n  const global = data.strapiGlobal\n\n  console.log(slug)\n  console.log(description)\n  console.log(content)\n  console.log(localizations)\n\n  const metadata = {\n    metaDescription: \"This is our Blog\",\n    metaTitle: \"Blog/InspiraLiving\",\n  }\n\n  return (\n    <>\n      <SEO seo={metadata} global={global} />\n      <Layout global={global} pageContext={{ ...pageContext, localizations }}>\n        {/**title */}\n        <ReactMarkdown children={content} remarkPlugins={[remarkGfm]} />\n      </Layout>\n    </>\n  )\n}\n\nexport default BlogPost\n\nexport const query = graphql`\n  fragment GlobalDataStrapi on StrapiGlobal {\n    favicon {\n      localFile {\n        publicURL\n      }\n    }\n    footer {\n      ctatext\n      description\n      rights\n      logo {\n        alternativeText\n        localFile {\n          childImageSharp {\n            gatsbyImageData(placeholder: BLURRED, formats: [AUTO, WEBP, AVIF])\n          }\n        }\n      }\n      id\n      button {\n        id\n        text\n        type\n      }\n    }\n    id\n    metaTitleSuffix\n    metadata {\n      metaDescription\n      metaTitle\n      shareImage {\n        localFile {\n          publicURL\n        }\n      }\n    }\n    navbar {\n      button {\n        id\n        newTab\n        text\n        type\n        url\n      }\n      id\n      links {\n        url\n        text\n        newTab\n        id\n      }\n      logo {\n        localFile {\n          childImageSharp {\n            gatsbyImageData(placeholder: BLURRED, formats: [AUTO, WEBP, AVIF])\n          }\n        }\n      }\n    }\n  }\n\n  query DynamicArticleQuery($id: String!, $locale: String!) {\n    strapiGlobal(locale: { eq: $locale }) {\n      ...GlobalData\n    }\n    strapiArticle(id: { eq: $id }) {\n      slug\n      title\n      description\n      content\n      localizations {\n        id\n        locale\n      }\n    }\n  }\n`\n"],"sourceRoot":""}